---
# Partitionning
- name: Get the UUID of /boot partition
  command: findmnt -no UUID /boot
  register: boot_uuid

- name: Ensure /boot partition in /etc/fstab has noauto option
  lineinfile:
    path: /etc/fstab
    regexp: '^(UUID={{ boot_uuid.stdout }}\s+/boot\s+xfs\s+)(.*)'
    line: 'UUID={{ boot_uuid.stdout }} /boot xfs noauto,\2'
    backrefs: yes

- name: Reload systemd to apply changes
  command: systemctl daemon-reload

- name: Ensure /boot is mounted as needed (optional)
  mount:
    path: /boot
    src: UUID={{ boot_uuid.stdout }}
    fstype: xfs
    opts: defaults
    state: mounted
  when: ansible_facts.mounts | selectattr('mount', '==', '/boot') | list | length == 0

- name: Set correct permissions on /boot
  file:
    path: /boot
    owner: root
    group: root
    mode: '0700'

#  Accounts
## Remove unused user accounts
- name: Find users inactive for more than {{ inactivity_days }} days
  shell: |
    lastlog -b {{ inactivity_days }} | awk '{if (NR>1) print $1}' | grep -v -E '{{ excluded_users | join("|") }}' || true
  register: inactive_users
  ignore_errors: yes

- name: Exclude users with running processes
  shell: |
    for user in {{ inactive_users.stdout_lines | join(" ") }}; do
      if ps -U $user > /dev/null 2>&1; then
        echo $user
      fi
    done
  register: users_with_processes

- name: Filter out users with running processes from the removal list
  set_fact:
    final_users_to_remove: "{{ inactive_users.stdout_lines | difference(users_with_processes.stdout_lines) }}"

- name: Debug list of final users to remove
  debug:
    msg: "{{ final_users_to_remove }}"

- name: Remove inactive users
  user:
    name: "{{ item }}"
    state: absent
    remove: yes  # Supprimer également le répertoire home de l'utilisateur
  loop: "{{ final_users_to_remove }}"
  when: final_users_to_remove is defined and final_users_to_remove|length > 0
## Userpassword strength
- name: Ensure password policies are enforced
  lineinfile:
    path: /etc/pam.d/system-auth
    regexp: '^password\s+requisite\s+pam_pwquality\.so'
    line: 'password requisite pam_pwquality.so retry=3 minlen=12 dcredit=-1 ucredit=-1 ocredit=-1 lcredit=-1'
  notify: reload_pam

- name: Ensure password reuse is restricted
  lineinfile:
    path: /etc/pam.d/system-auth
    regexp: '^password\s+sufficient\s+pam_unix\.so'
    line: 'password sufficient pam_unix.so sha512 shadow try_first_pass use_authtok remember=5'
  notify: reload_pam

## Configuring a timeout on local user sessions, to check : "echo $TMOUT"
- name: Ensure vlock is installed
  yum:
    name: vlock
    state: present

- name: Set TMOUT for CLI sessions in /etc/profile
  lineinfile:
    path: /etc/profile
    line: "export TMOUT={{ inactivity_timeout }}; readonly TMOUT; export LOCK_TTY=1"
    create: yes
    state: present

## Ensuring the imputability of administration actions
- name: Configure sudo for admin users
  copy:
    dest: "{{ sudoers_file }}"
    content: |
      # Sudo configuration for admin users
      %wheel ALL=(ALL) NOPASSWD: ALL
    mode: '0440'
  notify:
    - Validate sudoers configuration

- name: Disable root account
  user:
    name: root
    shell: /sbin/nologin

# - name: Set auditd rules to log all process creations
#   copy:
#     dest: "{{ auditd_rules_file }}"
#     content: |
#       -a exit,always -F arch=b64 -S execve,execveat
#       -a exit,always -F arch=b32 -S execve,execveat
#   notify:
#     - Reload auditd rules

## Services accounts
- name: "Disable shell access for service accounts"
  user:
    name: "{{ item.name }}"
    shell: "{{ item.shell }}"
  loop: "{{ service_accounts }}"
  when: item.action is not defined or item.action != 'disable'

- name: Ensure 'nobody' account is not used by multiple services
  shell: |
    for service in $(ps -eo user,comm | grep nobody | awk '{print $2}' | uniq); do
      echo "Service $service is using the nobody account. Consider configuring a unique user for it."
    done
  when: item.name == 'nobody'
  loop: "{{ service_accounts }}"

- name: Disable 'nobody' account from opening a shell
  user:
    name: nobody
    shell: /sbin/nologin


## Access Control
- name: S'assurer que la valeur umask est définie dans /etc/profile
  lineinfile:
    path: /etc/profile
    regexp: '^umask'
    line: 'umask 027'
    state: present
  notify: Reload profile

- name: Assurer que le groupe 'wheel' existe (groupe par défaut pour sudo sur RHEL/AlmaLinux)
  group:
    name: wheel
    state: present

- name: Restreindre l'accès à sudo aux seuls membres du groupe wheel
  lineinfile:
    path: /etc/sudoers
    regexp: '^%wheel'
    line: '%wheel ALL=(ALL) ALL'
    state: present
    validate: 'visudo -cf %s'

- name: Désactiver l'utilisation générale de sudo pour tous les utilisateurs sauf le groupe wheel
  lineinfile:
    path: /etc/sudoers
    regexp: '^Defaults\s+env_reset'
    line: 'Defaults env_reset, !targetpw, !rootpw, !runaspw'
    state: present
    validate: 'visudo -cf %s'

- name: Sécuriser les paramètres de sudo pour réduire les risques (requiretty)
  lineinfile:
    path: /etc/sudoers
    regexp: '^Defaults\s+requiretty'
    line: 'Defaults requiretty'
    state: present
    validate: 'visudo -cf %s'

- name: Configurer un fichier de log pour sudo
  lineinfile:
    path: /etc/sudoers
    regexp: '^Defaults\s+logfile'
    line: 'Defaults logfile="/var/log/sudo.log"'
    state: present
    validate: 'visudo -cf %s'

# - name: Vérifier les permissions et durcir le binaire sudo
#   file:
#     path: /usr/bin/sudo
#     owner: root
#     group: root
#     mode: '4750'


# TODO: R38+39+40 but the sudo causes crashes in the playbook

# SE Linux
- name: Check SELinux configuration file for SELINUX and SELINUXTYPE
  ansible.builtin.command: grep '^SELINUX\|SELINUXTYPE' /etc/selinux/config
  register: selinux_config

- name: Set SELINUX to enforcing if not already set
  ansible.builtin.replace:
    path: /etc/selinux/config
    regexp: '^SELINUX=.*'
    replace: 'SELINUX=enforcing'
  when: "'SELINUX=enforcing' not in selinux_config.stdout"

- name: Set SELINUXTYPE to targeted if not already set
  ansible.builtin.replace:
    path: /etc/selinux/config
    regexp: '^SELINUXTYPE=.*'
    replace: 'SELINUXTYPE=targeted'
  when: "'SELINUXTYPE=targeted' not in selinux_config.stdout"

- name: Schedule SELinux file system relabeling at next boot if not enforcing
  ansible.builtin.command: fixfiles onboot
  when: "'SELINUX=enforcing' not in selinux_config.stdout"

- name: Reload SELinux policy if not targeted
  ansible.builtin.command: semodule -R
  when: "'SELINUXTYPE=targeted' not in selinux_config.stdout"

- name: Reboot the server to apply SELinux changes
  ansible.builtin.reboot:
    msg: "Rebooting to apply SELinux enforcing mode and targeted policy"
    reboot_timeout: 600

- name: Verify SELinux status after reboot
  ansible.builtin.command: sestatus
  register: sestatus_output

- name: Ensure SELinux is active and enforcing with targeted policy
  ansible.builtin.debug:
    msg: "{{ sestatus_output.stdout }}"
  when: "'enabled' in sestatus_output.stdout and 'targeted' in sestatus_output.stdout and 'enforcing' in sestatus_output.stdout"
